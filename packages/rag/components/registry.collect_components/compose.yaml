compose:
  - call: lcod://tooling/script@1
    in:
      source: |
        async ({ state }) => {
          const pick = (value, fallback, defaultValue) => {
            if (typeof value === 'string' && value.length > 0) return value;
            if (typeof fallback === 'string' && fallback.length > 0) return fallback;
            return defaultValue;
          };
          const repoRoots = state.repoRoots && typeof state.repoRoots === 'object' && !Array.isArray(state.repoRoots)
            ? state.repoRoots
            : {};
          return {
            projectPath: pick(state.projectPath, state.cwd, '.'),
            specRoot: pick(state.specRoot, null, null),
            ragRoot: pick(state.ragRoot, state.cwd, '.'),
            repoRoots,
            cataloguesUrl: pick(
              state.cataloguesUrl,
              null,
              'https://raw.githubusercontent.com/lcod-team/lcod-registry/main/catalogues.json'
            ),
            cataloguesPath: pick(state.cataloguesPath, null, null)
          };
        }
      input:
        projectPath: $.projectPath
        specRoot: $.specRoot
        ragRoot: $.ragRoot
        repoRoots: $.repoRoots
        cataloguesUrl: $.cataloguesUrl
        cataloguesPath: $.cataloguesPath
        cwd: $.cwd
    out:
      projectPath: projectPath
      specRoot: specRoot
      ragRoot: ragRoot
      repoRoots: repoRoots
      cataloguesUrl: cataloguesUrl
      cataloguesPath: cataloguesPath

  - call: lcod://tooling/script@1
    in:
      source: |
        async ({ state }, { imports }) => {
          const warnings = [];
          const ensureString = (value) => (typeof value === 'string' && value.length > 0 ? value : null);
          let text = null;
          let decoded = null;

          const cataloguesUrl = ensureString(state.cataloguesUrl);
          let responseStatus = null;
          let responseBodyType = null;
          if (cataloguesUrl) {
            try {
              const response = await imports.httpRequest({
                method: 'GET',
                url: cataloguesUrl,
                headers: { accept: 'application/json' }
              });
              responseStatus = typeof response?.status === 'number' ? response.status : null;
              responseBodyType = typeof response?.body;
              if (responseStatus !== null && responseStatus >= 200 && responseStatus < 300) {
                const body = response?.body ?? null;
                if (typeof body === 'string') {
                  text = body;
                } else if (body && typeof body === 'object') {
                  decoded = body;
                } else {
                  warnings.push(`catalogues ${cataloguesUrl} returned an unexpected body shape`);
                }
              } else {
                warnings.push(
                  responseStatus !== null
                    ? `Failed to download catalogues from ${cataloguesUrl} (status ${responseStatus})`
                    : `Failed to download catalogues from ${cataloguesUrl}`
                );
              }
            } catch (error) {
              warnings.push(`HTTP error fetching ${cataloguesUrl}: ${error?.message || error}`);
            }
          }

          if (!text && !decoded) {
            const cataloguesPath = ensureString(state.cataloguesPath);
            if (cataloguesPath) {
              try {
                const absolute = cataloguesPath.startsWith('/')
                  ? cataloguesPath
                  : (await imports.pathJoin({ base: state.projectPath, segment: cataloguesPath }))?.path || cataloguesPath;
                const file = await imports.fsReadFile({ path: absolute, encoding: 'utf-8' });
                text = file?.data ?? null;
              } catch (error) {
                warnings.push(`Failed to read ${cataloguesPath}: ${error?.message || error}`);
              }
            }
          }

          let manifestObject = null;
          if (decoded && typeof decoded === 'object') {
            manifestObject = decoded;
          } else if (typeof text === 'string') {
            try {
              manifestObject = JSON.parse(text);
            } catch (error) {
              warnings.push(`Invalid JSON in catalogues: ${error?.message || error}`);
            }
          }

          let catalogues = [];
          if (manifestObject && typeof manifestObject === 'object') {
            if (Array.isArray(manifestObject.catalogues)) {
              catalogues = manifestObject.catalogues;
            } else {
              warnings.push('catalogues manifest missing "catalogues" array');
            }
          } else if (!cataloguesUrl && !state.cataloguesPath) {
            warnings.push('Unable to obtain catalogues manifest (no URL or local path provided)');
          } else if (!text && !decoded) {
            warnings.push('Unable to obtain catalogues manifest (HTTP and local fallback failed)');
          }

          return { catalogues, warnings, responseStatus, responseBodyType };
        }
      input:
        cataloguesUrl: $.cataloguesUrl
        cataloguesPath: $.cataloguesPath
        projectPath: $.projectPath
      imports:
        pathJoin: lcod://axiom/path/join@1
        fsReadFile: lcod://contract/core/fs/read-file@1
        httpRequest: lcod://contract/core/http/request@1
    out:
      catalogues: catalogues
      fetchWarnings: warnings
      cataloguesResponseStatus: responseStatus
      cataloguesResponseBodyType: responseBodyType

  - call: lcod://tooling/value/default_array@0.1.0
    in:
      value: $.fetchWarnings
    out:
      accumulatedWarnings: resolved

  - call: lcod://tooling/script@1
    in:
      source: |
        async ({ state }) => {
          const list = Array.isArray(state.catalogues) ? state.catalogues : [];
          return { list };
        }
      input:
        catalogues: $.catalogues
    out:
      cataloguesList: list

  - call: lcod://tooling/script@1
    in:
      source: |
        async ({ state }) => {
          const list = Array.isArray(state.catalogues) ? state.catalogues : [];
          return { count: list.length };
        }
      input:
        catalogues: $.cataloguesList
    out:
      cataloguesCount: count

  - call: lcod://tooling/value/default_object@0.1.0
    in:
      value:
        cataloguesCount: lcod://tooling/value/default_array@0.1.0

  - call: lcod://flow/foreach@1
    in:
      list: $.cataloguesList
    children:
      body:
        - call: lcod://tooling/value/default_object@0.1.0
          in:
            value: $slot.item
          out:
            catalogueObject: resolved

        - call: lcod://tooling/script@1
          in:
            source: |
              async ({ state }) => {
                const ensureString = (value) => (typeof value === 'string' && value.length > 0 ? value : null);
                const ensureObject = (value) => (value && typeof value === 'object' && !Array.isArray(value) ? value : null);
                const catalogue = ensureObject(state.catalogue) || {};
                const metadata = ensureObject(catalogue.metadata) || {};
                const warnings = [];

                const registryId = ensureString(catalogue.id) || 'catalogue';
                const priority = Number.isFinite(catalogue.priority) ? Math.trunc(catalogue.priority) : null;
                const manifestPath = ensureString(metadata.manifestPath);
                const manifestUrl = ensureString(metadata.manifestUrl) || ensureString(catalogue.url);
                const sourceRepo = ensureString(metadata.sourceRepo);
                const commit = ensureString(metadata.commit) || ensureString(catalogue.commit);

                if (!manifestPath && !manifestUrl) {
                  warnings.push(`catalogue ${registryId} is missing manifest reference`);
                }

                return {
                  sourceMetadata: {
                    registryId,
                    priority,
                    manifestPath: manifestPath || null,
                    manifestUrl: manifestUrl || null,
                    sourceRepo: sourceRepo || null,
                    description: ensureString(catalogue.description) || null,
                    commit,
                    metadata
                  },
                  warnings
                };
              }
            input:
              catalogue: $.catalogueObject
          out:
            sourceMetadata: sourceMetadata
            metadataWarnings: warnings

        - call: lcod://tooling/value/default_array@0.1.0
          in:
            value: $.metadataWarnings
          out:
            sourceWarnings: resolved

        - call: lcod://rag/registry/load_manifest_records@0.1.0
          in:
            metadata: $.sourceMetadata
            repoRoots: $.repoRoots
            projectPath: $.projectPath
            specRoot: $.specRoot
            ragRoot: $.ragRoot
          out:
            manifestRecords: records
            manifestWarnings: warnings

        - call: lcod://tooling/value/default_array@0.1.0
          in:
            value: $.manifestWarnings
          out:
            manifestWarningsList: resolved

        - call: lcod://tooling/array/append@0.1.0
          in:
            items: $.sourceWarnings
            values: $.manifestWarningsList
          out:
            sourceWarnings: items

        - call: lcod://tooling/value/default_array@0.1.0
          in:
            value: $.manifestRecords
          out:
            manifestRecordsList: resolved

        - call: lcod://flow/foreach@1
          in:
            list: $.manifestRecordsList
          children:
            body:
              - call: lcod://tooling/value/default_object@0.1.0
                in:
                  value: $slot.item
                out:
                  recordObject: resolved
              - call: lcod://rag/registry/normalize_component@0.1.0
                in:
                  record: $.recordObject
                  source: $.sourceMetadata
                out:
                  normalizedComponent: component
                  normalizedWarnings: warnings
              - call: lcod://impl/set@1
                in:
                  result:
                    component: $.normalizedComponent
                    warnings: $.normalizedWarnings
                out:
                  result: result
          collectPath: $.result
          out:
            normalizationResults: results

        - call: lcod://rag/array/pluck@0.1.0
          in:
            items: $.normalizationResults
            field: 'component'
          out:
            componentsList: values

        - call: lcod://rag/array/compact@0.1.0
          in:
            items: $.componentsList
          out:
            componentsList: values

        - call: lcod://rag/array/pluck@0.1.0
          in:
            items: $.normalizationResults
            field: 'warnings'
          out:
            normalizationWarningsNested: values

        - call: lcod://rag/array/flatten@0.1.0
          in:
            items: $.normalizationWarningsNested
          out:
            normalizationWarnings: values

        - call: lcod://tooling/value/default_array@0.1.0
          in:
            value: $.normalizationWarnings
          out:
            normalizationWarningsList: resolved

        - call: lcod://tooling/array/append@0.1.0
          in:
            items: $.sourceWarnings
            values: $.normalizationWarningsList
          out:
            sourceWarnings: items

        - call: lcod://impl/set@1
          in:
            entry:
              components: $.componentsList
              warnings: $.sourceWarnings
          out:
            entry: entry
    collectPath: $.entry
    out:
      perCatalogueResults: results

  - call: lcod://rag/array/pluck@0.1.0
    in:
      items: $.perCatalogueResults
      field: 'components'
    out:
      componentsNested: values

  - call: lcod://rag/array/flatten@0.1.0
    in:
      items: $.componentsNested
    out:
      components: values

  - call: lcod://rag/array/pluck@0.1.0
    in:
      items: $.perCatalogueResults
      field: 'warnings'
    out:
      warningsNested: values

  - call: lcod://rag/array/flatten@0.1.0
    in:
      items: $.warningsNested
    out:
      perCatalogueWarnings: values

  - call: lcod://tooling/value/default_array@0.1.0
    in:
      value: $.perCatalogueWarnings
    out:
      perCatalogueWarningsList: resolved

  - call: lcod://tooling/array/append@0.1.0
    in:
      items: $.accumulatedWarnings
      values: $.perCatalogueWarningsList
    out:
      warnings: items

  - call: lcod://tooling/script@1
    in:
      source: |
        async ({ state }) => {
          const list = Array.isArray(state.components) ? state.components : [];
          return { componentCount: list.length };
        }
      input:
        components: $.components
    out:
      componentCount: componentCount

  - call: lcod://impl/set@1
    in:
      components: $.components
      warnings: $.warnings
      componentCount: $.componentCount
      cataloguesCount: $.cataloguesCount
    out:
      components: components
      warnings: warnings
      componentCount: componentCount
      cataloguesCount: cataloguesCount
