compose:
  - call: lcod://tooling/script@1
    in:
      source: |
        async ({ state }, api) => {
          const vectors = Array.isArray(state.vectors) ? state.vectors : [];
          const warnings = [];
          const env = typeof process !== 'undefined' && process && process.env ? process.env : {};

          const baseUrlRaw = typeof state.qdrantUrl === 'string' ? state.qdrantUrl : (env.QDRANT_URL || 'http://localhost:6333');
          const collectionRaw = typeof state.collection === 'string' && state.collection.trim().length
            ? state.collection
            : (env.QDRANT_COLLECTION || 'lcod_docs');
          const apiKey = typeof state.apiKey === 'string' ? state.apiKey : (env.QDRANT_API_KEY || null);
          const batchSize = Number.isFinite(state.batchSize)
            ? Math.max(1, Math.trunc(state.batchSize))
            : 32;
          const timeout = Number.isFinite(state.timeoutMs)
            ? Math.max(1000, Math.trunc(state.timeoutMs))
            : 15000;

          const stripTrailingSlash = (value) => value.replace(/\/+$/, '');
          const baseUrl = stripTrailingSlash(baseUrlRaw);
          const collection = collectionRaw.trim();

          const headers = {
            accept: 'application/json',
            'content-type': 'application/json'
          };
          if (apiKey) {
            headers['api-key'] = apiKey;
          }

          const ensureString = (value) => {
            if (typeof value !== 'string') return null;
            const trimmed = value.trim();
            return trimmed.length ? trimmed : null;
          };

          const normalizeVector = (input) => {
            if (!Array.isArray(input)) return null;
            const numbers = [];
            for (const value of input) {
              const parsed = Number(value);
              if (!Number.isFinite(parsed)) {
                return null;
              }
              numbers.push(parsed);
            }
            return numbers;
          };

          const pickMetadata = (meta) => {
            if (!meta || typeof meta !== 'object' || Array.isArray(meta)) return {};
            const payload = {};

            const assign = (key, value) => {
              if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
                payload[key] = value;
              }
            };

            assign('componentId', meta.componentId);
            assign('version', meta.version);
            assign('docKey', meta.docKey);
            assign('docUrl', meta.docUrl);
            assign('repo', meta.repo);
            assign('manifest', meta.manifest);
            assign('composePath', meta.composePath);
            assign('commit', meta.sourceMetadata && meta.sourceMetadata.commit);
            assign('registryId', meta.registryId);
            assign('priority', meta.priority);

            return payload;
          };

          const makeId = () => {
            if (globalThis.crypto && typeof globalThis.crypto.randomUUID === 'function') {
              return globalThis.crypto.randomUUID();
            }
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (char) => {
              const rand = Math.random() * 16 | 0;
              const value = char === 'x' ? rand : (rand & 0x3) | 0x8;
              return value.toString(16);
            });
          };

          let upserted = 0;

          for (let offset = 0; offset < vectors.length; offset += batchSize) {
            const batch = vectors.slice(offset, offset + batchSize);
            const points = [];

            for (const entry of batch) {
              if (!entry || typeof entry !== 'object' || Array.isArray(entry)) {
                continue;
              }
              const vector = normalizeVector(entry.vector);
              const text = ensureString(entry.text);
              if (!vector || !text) {
                warnings.push('ingest.upsert_chunks: skipped invalid vector payload');
                continue;
              }
              const metadata = pickMetadata(entry.metadata);
              metadata.text = text;

              points.push({
                id: makeId(metadata),
                vector,
                payload: metadata
              });
            }

            if (!points.length) {
              continue;
            }

            try {
              const response = await api.call('lcod://contract/core/http/request@1', {
                method: 'PUT',
                url: `${baseUrl}/collections/${encodeURIComponent(collection)}/points`,
                headers,
                body: { points },
                bodyEncoding: 'json',
                timeoutMs: timeout
              });

              const status = Number.isFinite(response?.status) ? response.status : null;
              if (!status || status < 200 || status >= 300) {
                const bodyPreview = typeof response?.body === 'string'
                  ? response.body.slice(0, 200)
                  : JSON.stringify(response?.body)?.slice(0, 200);
                warnings.push(`ingest.upsert_chunks: batch starting at ${offset} returned status ${status ?? 'unknown'} ${bodyPreview ? `body=${bodyPreview}` : ''}`.trim());
              } else {
                upserted += points.length;
              }
            } catch (error) {
              warnings.push(`ingest.upsert_chunks: HTTP error while uploading batch starting at ${offset}: ${error?.message || error}`);
            }
          }

          return {
            upserted,
            warnings
          };
        }
      input:
        vectors: $.vectors
        collection: $.collection
        qdrantUrl: $.qdrantUrl
        apiKey: $.apiKey
        batchSize: $.batchSize
        timeoutMs: $.timeoutMs
    out:
      upserted: upserted
      warnings: warnings
